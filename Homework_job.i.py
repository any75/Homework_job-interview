# Домашнее задание к лекции 7. «Подготовка к собеседованию»
# Стек — абстрактный тип данных, представляющий список элементов, организованных по принципу
# LIFO (англ. last in — first out, «последним пришёл — первым вышел»). Чаще всего принцип работы стека
# сравнивают со стопкой тарелок: чтобы взять вторую сверху, нужно снять верхнюю. Или с магазином в
# огнестрельном оружии: стрельба начнётся с патрона, заряженного последним.
#
# Нужно реализовать класс Stack со следующими методами:
# is_empty — проверка стека на пустоту. Метод возвращает True или False;
# push — добавляет новый элемент на вершину стека. Метод ничего не возвращает;
# pop — удаляет верхний элемент стека. Стек изменяется. Метод возвращает верхний элемент стека;
# peek — возвращает верхний элемент стека, но не удаляет его. Стек не меняется;
# size — возвращает количество элементов в стеке.


# Задание № 1
class Stack:
    def __init__(self):
        self.collection = []

    def is_empty(self):
        # проверка стека на пустоту. Метод возвращает True или False
        return len(self.collection) == 0

    def push(self, item):
        # добавляет новый элемент на вершину стека. Метод ничего не возвращает;
        self.collection.append(item)

    def pop(self):
        # удаляет верхний элемент стека. Стек изменяется. Метод возвращает верхний элемент стека;
        if self.is_empty() == False: # if not self.is_empty():
            value = self.collection.pop()
            return value
        else:
            return 'Коллекция пустая'

    def peek(self):
        # возвращает верхний элемент стека, но не удаляет его. Стек не меняется;
        if self.is_empty() == False: # if not self.is_empty():
            return self.collection[-1]
        else:
            return 'Коллекция пустая'

    def size(self):
        # возвращает количество элементов в стеке
        return len(self.collection)


# x = 0
# print(bool(x))
# print(x == 0)
# x = []
# x.pop()
# Используя стек из задания 1, решите задачу на проверку сбалансированности скобок.
# Сбалансированность скобок означает, что каждый открывающий символ имеет соответствующий ему закрывающий,
# и пары скобок правильно вложены друг в друга.
# Пример сбалансированных последовательностей скобок:
#
# (((([{}]))))
# [([])((([[[]]])))]{()}
# {{[()]}}
# Несбалансированные последовательности:
#
# }{}
# {{[(])]}}
# [[{())}]
# Программа ожидает на вход строку со скобками. На выход сообщение: «Сбалансированно», если строка корректная,
# и «Несбалансированно», если строка составлена неверно.

# три вида скобок: [] () {}

# Задание № 2
def brackets(data):
    b_dict = {')': '(',
              ']': '[',
              '}': '{'}
    stack = Stack()
    flag = True

    for i in range(len(data)):
        #print(f'i-> {i}, bracket-> {data[i]}')
        if data[i] in '([{':
            stack.push(data[i])
            #print(stack.collection)
        elif data[i] in ')]}' and i == 0:
            stack.push(data[i])
            flag = False
            break
        elif data[i] in ')]}':
            #print(data[i], stack.collection[-1])

            # print(data[i], data[i-1], b_dict[data[i]])
            if stack.collection[-1] == b_dict[data[i]]:
                #print(stack.collection[-1], b_dict[data[i]])
                stack.pop()
                #print(stack.collection)
            else:
                break

    if stack.is_empty():
        flag = True
    else:
        flag = False

    if flag:
        print('Сбалансированная последовательность')
    else:
        print('Несбалансированная последовательность')


# print('((([{}])))')
# brackets('((([{}])))')
# print()
# print('[([])((([[[]]])))]{()}')
# brackets('[([])((([[[]]])))]{()}')
# print()
# print('{{[()]}}')
# brackets('{{[()]}}')
# print()
# print()
# print('}{}')
# brackets('}{}')
# print()
# print('{{[(])}}')
# brackets('{{[(])]}}')
# print()
# print('[[{())}]')
# brackets('[[{())}]')
# [([])((([[[]]])))]{()}
# {{[()]}}
# Несбалансированные последовательности:
#
# brackets('}{}')
# {{[(])]}}
# [[{())}]



